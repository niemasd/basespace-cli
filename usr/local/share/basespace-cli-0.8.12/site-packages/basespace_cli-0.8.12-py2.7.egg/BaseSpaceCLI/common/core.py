import sys
import logging
import argparse
import pkg_resources
import textwrap
import os

from pkg_resources import EntryPoint

from cliff.app import App
from cliff.command import Command

from .. import __version__,__summary__,__description__
from .. import __log_terse_level__,__console_width__
from .help import HelpFormatter,HelpAction
from .version import VersionAction,VersionCommand
from .command_manager import DualCommandManager
from .entities import all_entities,entity_parsers
from .bash_completion import BashCompletion
from ..tools.complete import Complete


BOLD     = "\033[1m"
NOT_BOLD = "\033[21m"
DIM      = "\033[2m"
NOT_DIM  = "\033[22m"
RESET    = "\x1b[0m"


class ConsoleFilter(logging.Filter):
    fmt = '%(message)s'
    def filter(self, record):
        return record.levelno == logging.INFO \
            or record.levelno == __log_terse_level__


class DebuggingFilter(logging.Filter):
    fmt = DIM+'%(message)s'+NOT_DIM+RESET
    def filter(self, record):
        return record.levelno == logging.DEBUG


class SevereFilter(logging.Filter):
    fmt = '%(levelname)-8s: '+BOLD+'%(message)s'+NOT_BOLD+RESET
    def filter(self, record):
        return record.levelno == logging.CRITICAL \
            or record.levelno == logging.ERROR \
            or record.levelno == logging.WARNING


class CLI(App):
    LOG_FILE_MESSAGE_FORMAT = '%(asctime)s [%(name)s] %(levelname)-8s: %(message)s'
    
    exc_info = None
    basespace_dir = os.path.join(os.path.expanduser("~"), ".basespace")
    _config_path = None
    additional_parsers = []

    def __init__(self):
        self.LOG = logging.getLogger(self.NAME)
        CM = DualCommandManager(self.basespace_dir)
        description="\n".join(textwrap.wrap(__description__,__console_width__))
        self.deferred_version = True
        super(CLI, self).__init__(
            description="\n\n".join( [__summary__,description] ),
            version=__version__,
            command_manager=CM,
            deferred_help=True
        )
        self.command_manager.add_command('version', VersionCommand)
        self.command_manager.add_command('complete', Complete)
        self.complete = BashCompletion(self.basespace_dir)

    @property
    def config_path(self):
        if not self._config_path:
            self._config_path = os.path.join( self.basespace_dir,
                                              "%s.cfg" % (self.options.config if self.options.config else "default") )
        return self._config_path


    def build_option_parser(self, description, version, argparse_kwargs=None):
        parser = super(CLI, self).build_option_parser(
                                      description,
                                      version,
                                      argparse_kwargs={'conflict_handler' : 'resolve',
                                                       'usage' : '  %(prog)s [options] <COMMAND> [cmd-options]',
                                                       'formatter_class' : HelpFormatter }
                 )
        if self.deferred_version:
            parser.add_argument(
                '-V', '--version',
                dest='deferred_version',
                action='store_true',
                help="Show version number and exit.",
            )
        else:
            parser.add_argument(
                '-V', '--version',
                action=VersionAction,
                nargs=0,
                default=self,  # tricky
                help="Show version number and exit.",
            )
        parser.add_argument(
            '--dry-run',
            action="store_true",
            default=False,
            help="Rehearsing COMMAND, without actually running it."
        )
        parser.add_argument(
            '-c','--config',
            action="store",
            default="default",
            help="Configuration id, to be used to access: ~/.basespace/<CONFIG>.cfg"
        )
        parser.add_argument(
            '--terse',
            action="store_true",
            default=False,
            help="Output relevant BaseSpace IDs to stdout, but nothing else; warnings and errors still appear on stderr"
        )
        return parser


    def very_verbose(self):
        return (self.options.verbose_level > 2)

    def ultra_verbose(self):
        return (self.options.verbose_level > 3)

    def print_help_if_requested(self):
        if self.deferred_help and self.options.deferred_help:
            self.LOG.debug( "Changing bash-completion information" )
            self.complete.write(self)
            self.complete.enable()
            action = HelpAction(None, None, default=self)
            action(self.parser, self.options, None, None)

    def _create_stream_handle(self, stream, filter):
        # convert command-line option to logging level, defaulting to debug if verbose_level didn't exist
        # (but this should never happen; even when no command-line has been given verbose_level has a default value)
        level = { 0: logging.WARNING,
                  1: logging.INFO,
                  2: logging.DEBUG,
                }.get(self.options.verbose_level, logging.DEBUG)
        handle = logging.StreamHandler(stream)
        handle.setLevel(level)
        formatter = logging.Formatter(filter.fmt)
        handle.setFormatter(formatter)
        handle.addFilter(filter)
        return handle

    def _create_file_handle(self, filename):
        handle = logging.FileHandler(filename=filename)
        #handle.setLevel(logging.DEBUG)
        formatter = logging.Formatter(self.LOG_FILE_MESSAGE_FORMAT)
        handle.setFormatter(formatter)
        return handle


    def configure_logging(self):
        if self.options.terse:
            self.options.verbose_level = 0
        root_logger = logging.getLogger('')
        root_logger.setLevel(logging.DEBUG)
        if self.options.log_file:
            root_logger.addHandler( self._create_file_handle( os.path.expanduser(self.options.log_file) ))
        root_logger.addHandler( self._create_stream_handle( self.stdout, ConsoleFilter() ))
        root_logger.addHandler( self._create_stream_handle( self.stderr, DebuggingFilter() ))
        root_logger.addHandler( self._create_stream_handle( self.stderr, SevereFilter() ))
        #print logging.Logger.manager.loggerDict  ## all loggers

        if not self.ultra_verbose():
            # shut down stevedore's logger, unless verbosity is way beyond standard
            slog=logging.getLogger('stevedore')
            slog.setLevel(logging.INFO)

        return


    def initialize_app(self, argv):
        #import pdb;pdb.set_trace()
        if self.deferred_version and self.options.deferred_version:
            self.interactive_mode = False # avoid triggering interact() due to all options being consumed
            self.options.deferred_version = False
            argv.insert(0, "version")

        self.LOG.debug('Initializing command-line interface...')
        self.LOG.debug('...   args: %s', argv)
        self.command_manager.set_config(self.config_path)
        self.LOG.debug('... config: %s', self.config_path)
        self.load_commands()
        if 'list' in argv:
            for arg in argv:
                if arg in all_entities:
                    self.additional_parsers.append( entity_parsers[arg]() )


    def load_commands(self):
        self.LOG.debug('Loading commands...')
        self.command_manager.load_commands('builtin',visible=True)
        self.command_manager.load_commands('alias')
        self.command_manager.load_commands('discoverable')
        self.command_manager.load_from_file()
        for name, ep in sorted(self.command_manager):
            self.LOG.debug("%r",ep)
            if ep.get_path():
                if self.very_verbose():
                    self.LOG.debug("    ... enabling '%s'", name)
                ep.make_visible()
        self.LOG.debug('... done loading commands')


    def prepare_to_run_command(self, cmd):
        self.LOG.debug('Preparing to run command: %s', cmd.__class__.__name__)
        #import pdb;pdb.set_trace()


    def clean_up(self, cmd, result, err):
        cmd_name = cmd.__class__.__name__
        if cmd_name in self.complete.triggers:
            self.LOG.debug( "Changing bash-completion information" )
            self.complete.write(self)
            self.complete.enable()
        self.LOG.debug('Cleaning up after command: %s', cmd_name)
        if err:
            self.LOG.debug('  ... error: %r', err)
            self.exc_info = sys.exc_info()
        if result:
            self.LOG.debug('  ... exit code: %r', result)


    def interact(self):
        #self.stdout.write("Type '%s --help' for more information\n" % sys.argv[0])
        self.options.deferred_help = True
        self.print_help_if_requested()
        return 1

