import argparse
import sys
import os
import re
import traceback
from collections import defaultdict

from cliff.command import Command

from .. import __console_width__


class HelpFormatter(argparse.RawDescriptionHelpFormatter):
    def __init__(self, prog, indent_increment=2, max_help_position=32, width=__console_width__):  # width=None
        super(HelpFormatter, self).__init__(prog, indent_increment, max_help_position, width)

    def start_section(self, heading):
        # Title-case the headings.
        heading = '%s%s' % (heading[0].upper(), heading[1:])
        super(HelpFormatter, self).start_section(heading)

    def _split_lines(self, text, width):
        if text.startswith('S|'):
            return text[2:].splitlines()  
        return argparse.HelpFormatter._split_lines(self, text, width)


class SubHelpFormatter(HelpFormatter):
    def __init__(self, prog, indent_increment=2, max_help_position=42, width=__console_width__):  # width=None
        super(SubHelpFormatter, self).__init__(prog, indent_increment, max_help_position, width)


def get_man_command():
    head,tail = os.path.split(sys.argv[0])
    while head and tail and tail != "share":
        head,tail = os.path.split(head)
    manpath = re.sub(r"^/+(.*)",r"/\1",os.path.join(head,"share","man"))
    if not os.path.isdir(manpath):
        return ""
    try:
        with open(os.path.join('','etc','man.config'),'r') as fh:
            for line in fh:
                parts = line.split()
                if parts[0] == "MANPATH" and parts[1] == manpath:
                    return "man bs"
    except IOError:
        try:
            with open(os.path.join('','etc','manpath.config'),'r') as fh:
                for line in fh:
                    parts = line.split()
                    if parts[0] == "MANDATORY_MANPATH" and parts[1] == manpath:
                        return "man bs"
        except IOError:
            pass
    return "MANPATH=%s man bs" % manpath

class HelpAction(argparse.Action):

    category_order = ["Credentials", "Creating and listing", "Apps", "Filesystem", "Configuration", "Other"]

    def __call__(self, parser, namespace, values, option_string=None):
        epilog = ["See 'bs help COMMAND' for more information on a specific command."]
        manCmd = get_man_command()
        if manCmd:
            epilog[0] = epilog[0][:-1] + ','
            epilog.append(" or do '%s' for more information in general." % manCmd)
        app = self.default
        parser.print_help(app.stdout)
        app.stdout.write('\nCommands:\n')
        command_manager = app.command_manager
        command_categories = defaultdict(list)
        for name, ep in sorted(command_manager.__visible__):
            category = ep.get_category()
            if not category:
                category = "Other"
            command_categories[category].append((name, ep))
        for category in self.category_order:
            if category not in command_categories:
                continue
            app.stdout.write(' %s:\n' % category)
            for name, ep in command_categories[category]:
                try:
                    factory = ep.load(require=False)
                except Exception as err:
                    app.stderr.write('Could not load %r: %s\n' % (ep, err))
                    if namespace.debug:
                        traceback.print_exc(file=app.stderr)
                    continue
                try:
                    cmd = factory(app, None)
                    if cmd.deprecated:
                        continue
                except Exception as err:
                    app.stderr.write('Could not instantiate %r: %s\n' % (ep, err))
                    if namespace.debug:
                        traceback.print_exc(file=app.stderr)
                    continue
                one_liner = ep.get_description(cmd).split('\n')[0]
                app.stdout.write('  %-26s  %s\n' % (name, one_liner))
        app.stdout.write( "\n" )
        app.stdout.write( "\n".join(epilog) )
        app.stdout.write( "\n" )
        sys.exit(0)

