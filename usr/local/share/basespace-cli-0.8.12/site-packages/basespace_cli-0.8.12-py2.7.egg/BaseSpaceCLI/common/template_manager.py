import json
import os
import pkgutil

from BaseSpacePy.api.BaseSpaceException import ServerResponseException

class TemplateManagerException(Exception):
    pass


class Template(object):
    SAVE_KEYS = set(["name", "properties", "defaults", "version"])

    def __init__(self, name, basespaceid, version, properties, defaults, source):
        self.name = name
        self.basespaceid = basespaceid
        self.version = version
        self.properties = properties
        self.defaults = defaults
        self.source = source

    def as_dict(self):
        base_dict = dict((key, getattr(self, key)) for key in self.SAVE_KEYS)
        base_dict["defaultid"] = self.basespaceid
        return base_dict

    def __str__(self):
        return """
app name: %s
app version: %s
basespaceid: %s
properties:
%s
defaults:
%s
""" % (self.name, self.version, self.basespaceid, json.dumps(self.properties, indent=4), json.dumps(self.defaults, indent=4))


class TemplateManager(object):
    def __init__(self, config_path, api):
        """
        :param templatefile: path to file containing templates
        """
        self._local_templatefile = os.path.splitext(config_path)[0] + "-apps.json"
        self._templates_by_id = {}
        self._api = api
        self._basespace_apps = {}
        self.read_template_file()

    def has_basespaceid(self, id):
        return id in self._templates_by_id

    def get_basespaceid(self, app_name, app_version, defaultid=None):
        if not self._basespace_apps:
            raw_apps = self._api.getApplications()
            for app in raw_apps:
                self._basespace_apps[app.Name] = app
        if app_name in self._basespace_apps:
            if self._basespace_apps[app_name].VersionNumber != app_version:
                # if the version numbers don't match, see if we can use a default ID to get a previous version
                if defaultid:
                    try:
                        self._api.getApplicationById(defaultid)
                        return defaultid
                    except ServerResponseException:
                        raise TemplateManagerException("Can't find app: %s(%s)" % (app_name, app_version))
            return self._basespace_apps[app_name].Id
        else:
            raise TemplateManagerException("App not found")

    def read_template_file(self):
        canned_templates = json.loads(
            pkgutil.get_data('BaseSpaceCLI', os.path.join('data', 'apps.json')))

        local_templates = {}
        if os.path.exists(self._local_templatefile) and os.path.getsize(self._local_templatefile) != 0:
            try:
                with open(self._local_templatefile) as fh:
                    local_templates = json.load(fh)
            except ValueError as e:
                raise TemplateManagerException("Invalid template file: %s (%s)" % (self._local_templatefile, str(e)))
        else:
            self._save_template_file()

        # unpack both the canned (centralised) and local templates
        for template in canned_templates:
            self.unpack_template(template, "preset")
        # when we unpack the local templates,
        # use the force parameter to make them override the preset templates
        for template in local_templates:
            self.unpack_template(template, self._local_templatefile, force=True)

    def unpack_all_templates(self, all_templates, force=False):
        for template in all_templates:
            self.unpack_template(template, self._local_templatefile, force)
        self._save_template_file()

    def unpack_template(self, template, source, force=False):
        try:
            name = template["name"]
            version = template["version"]
            properties = template["properties"]
            defaults = template["defaults"]
            defaultid = template["defaultid"] if "defaultid" in template else None
            # if this is a forced unpack, use the ID provided in the template file
            # don't try to get one from the matched BaseSpace instance.
            # This is what will happen for a config-specific template
            if force:
                basespaceid = defaultid
            else:
                basespaceid = self.get_basespaceid(name, version, defaultid)
        except KeyError as e:
            try:
                name
            except NameError:
                name = ""
            raise TemplateManagerException("Missing field for template: %s (%s)" % (str(e), name))
        except TemplateManagerException as e:
            # we were unable to find the appid for this app - don't add it to the list
            return
        t = Template(name, basespaceid, version, properties, defaults, source)
        self._add_template(t, force)

    def get_app_template_by_basespace_id(self, basespaceid):
        if basespaceid not in self._templates_by_id:
            raise TemplateManagerException("No template with ID: %s" % basespaceid)
        return self._templates_by_id[basespaceid]

    def get_app_templates_by_name(self, name_pattern):
        return [self._templates_by_id[id_] for id_ in self._templates_by_id if
                name_pattern.lower() in self._templates_by_id[id_].name.lower()]

    def get_all_templates(self):
        return self._templates_by_id.values()

    def get_all_local_templates_raw(self):
        """
        get all the local templates - used by the save routine
        """
        return [t.as_dict() for t in self._templates_by_id.values() if t.source == self._local_templatefile]

    def add_app_template(self, name, basespaceid, version, properties, defaults, force=False):
        """
        public function for tools to add a template and save it into the file
        :param name: name of app
        :param basespaceid: BaseSpace ID
        :param version: App version
        :param properties: dict of properties
        :param defaults: dict of default values
        """
        t = Template(name, basespaceid, version, properties, defaults, self._local_templatefile)
        self._add_template(t, force)
        self._save_template_file()

    def _add_template(self, t, force):
        """
        :param t: a template object
        :param force: whether to replace/overwrite a template in the existing datastructure
        this method is used both when loading templates from file
        and when adding a new template with a command line
        I think there might be an edge case here where apps have the same ID but different names
        and behavior will be unpredictable under these conditions
        but I don't think this can occur unless the user manually edits their template file
        and at that point, all bets are off!
        """
        if not force and t.basespaceid in self._templates_by_id:
            raise TemplateManagerException("Two apps with same id: %s" % t.basespaceid)
        self._templates_by_id[t.basespaceid] = t

    def _save_template_file(self):
        """
        Always save templates into the local file
        :return:
        """
        with open(self._local_templatefile, "w") as fh:
            json.dump(self.get_all_local_templates_raw(), fh)
