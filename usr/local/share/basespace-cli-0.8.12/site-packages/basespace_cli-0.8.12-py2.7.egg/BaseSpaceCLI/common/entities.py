#
# Copyright (c) 2015 Illumina, Inc.
#
# This software is provided under the terms and conditions of the
# Illumina Open Source Software License 1.
#
# You should have received a copy of the Illumina Open Source
# Software License 1 along with this program. If not, see
# <https://github.com/sequencing/licenses/>
#

"""
List entity types from BaseSpace.

Provides a common set of tools for listing; used by list samples, list projects, list appresults

"""

import abc
import fnmatch

from BaseSpacePy.model.QueryParameters import QueryParameters as qp
from BaseSpacePy.api.AppLaunchHelpers import LaunchSpecification

from .template_manager import TemplateManager
from .parsers import ProjectParser,SampleParser,AppresultParser,AppsessionParser,TemplateParser,RunsParser


entity_parsers = {
                  'projects'    : ProjectParser,
                  'samples'     : SampleParser,
                  'appresults'  : AppresultParser,
                  'appsessions' : AppsessionParser,
                  'apps'        : TemplateParser,
                  'runs'         : RunsParser
                 }

all_entities = entity_parsers.keys()


class EntityException(Exception):
    def __init__(self, value, entity='entities'):
        self.parameter = "Error processing " + str(entity) + ": " + str(value)

    def __str__(self):
        return repr(self.parameter)

def sanitise_string(string):
    return ("%s" % string).encode('ascii', 'ignore')


def entity_extractor_factory(parsed_args, app_options, api, config_path):
    "factory to produce the right type of object to extract entities based on command line arguments"

    additional_args = {
        "with_projects": ('projects' in parsed_args.entities),
    }
    # if the terse option is selected, it applies to the first entity selected
    if app_options.terse:
        additional_args["terse"] = parsed_args.entities[0]
    else:
        additional_args["terse"] = ""
    if ('projects' in parsed_args.entities) or ('samples' in parsed_args.entities) or ('appresults' in parsed_args.entities):
        projects = api.getProjectByUser()
        if hasattr(parsed_args, "project_name") and parsed_args.project_name:
            pname = parsed_args.project_name
            projects = [ project for project in projects if fnmatch.fnmatch(sanitise_string(project.Name), pname)]

    if 'samples' in parsed_args.entities:
        additional_args["project_list"] = projects
        additional_args["with_properties"] = parsed_args.with_properties if hasattr(parsed_args, "with_properties") else False
        additional_args["sample_name"] = parsed_args.sample_name if hasattr(parsed_args, "sample_name") else ""
        if app_options.terse and parsed_args.with_properties:
            raise EntityException("Cannot specify extra columns with terse","samples")
        ExtractorObject = SampleExtractor
    elif 'appresults' in parsed_args.entities:
        additional_args["project_list"] = projects
        additional_args["appresult_name"] = parsed_args.appresult_name if hasattr(parsed_args, "appresult_name") else ""
        ExtractorObject = AppResultExtractor
    elif 'appsessions' in parsed_args.entities:
        if app_options.terse and parsed_args.extended:
            raise EntityException("Cannot specify extra columns with terse","appsessions")
        if not hasattr(parsed_args, "status"):
            raise EntityException("Cannot add appsessions to list projects. Use 'list appsessions projects' instead.","projects")
        additional_args["status"] = ",".join(parsed_args.status)
        additional_args["extended"] = parsed_args.extended
        additional_args["appsession_name"] = parsed_args.appsession_name
        if hasattr(parsed_args, "project_name") and parsed_args.project_name:
            pname = parsed_args.project_name
            additional_args["project_name"] = pname
        ExtractorObject = AppSessionExtractor
    elif 'apps' in parsed_args.entities:
        if parsed_args.id and parsed_args.appname:
            raise EntityException("Cannot specify both name and appid","templates")
        additional_args["id"] = parsed_args.id
        additional_args["appname"] = parsed_args.appname
        additional_args["all_apps"] = parsed_args.all_apps
        additional_args["app_options"] = parsed_args.app_options
        additional_args["template_manager"] = TemplateManager(config_path, api)
        ExtractorObject = TemplateExtractor
    elif 'runs' in parsed_args.entities:
        if set(parsed_args.entities) - set(("runs",)):
            raise EntityException("Cannot list runs with other entities")
        additional_args["extended"] = parsed_args.extended
        ExtractorObject = RunsExtractor
    else:
        additional_args["project_list"] = projects
        ExtractorObject = ProjectExtractor
    return ExtractorObject(api, **additional_args)


class EntityExtractor(object):
    __metaclass__ = abc.ABCMeta

    'Pulls out entities to be listed'

    def __init__(self, api, with_projects, terse):
        self._api = api
        self._with_projects = with_projects
        self._terse = terse

    @abc.abstractmethod
    def _get_specific_headers(self):
        pass

    def _get_header(self):
        if self._terse:
            return ("ID",)
        headers = []
        if self._with_projects:
            headers.extend(["project id", "project name"])
        return headers + self._get_specific_headers()

    @abc.abstractmethod
    def _get_entries(self):
        pass

    def get_header_and_entries(self):
        header = self._get_header()
        entries = self._get_entries()
        # if len(header) != len(entries):
        #     raise EntityException("header length does not match data length")
        return header, entries


class SampleExtractor(EntityExtractor):
    def __init__(self, api, with_projects, terse, project_list, with_properties, sample_name):
        super(SampleExtractor, self).__init__(api, with_projects, terse)
        self._project_list = project_list
        self._with_properties = with_properties
        self._sample_name = sample_name

    def _get_specific_headers(self):
        specific_headers = ["sample id", "sample name"]
        if self._with_properties:
            specific_headers.append("properties")
        return specific_headers

    def _get_entries(self):
        for project in self._project_list:
            samples = project.getSamples(self._api)
            if self._sample_name:
                samples = [sample for sample in samples if fnmatch.fnmatch(sanitise_string(sample.Name), self._sample_name)]
            for sample in samples:
                if self._terse == "samples":
                    yield (sample.Id,)
                    continue
                row = sample.Id, sanitise_string(sample.Name)
                if self._with_projects:
                    if self._terse == "projects":
                        yield (project.Id,)
                        continue
                    row = (project.Id, sanitise_string(project.Name)) + row
                if self._with_properties:
                    properties = self._api.getResourceProperties("samples", sample.Id)
                    properties_str = ";".join(
                        ("%s=%s" % (prop.Name, prop.Content) for prop in properties.Items if prop.Type == "string"))
                    row = row + (properties_str,)
                yield row


class ProjectExtractor(EntityExtractor):
    def __init__(self, api, with_projects, terse, project_list):
        super(ProjectExtractor, self).__init__(api, with_projects, terse)
        self._project_list = project_list

    def _get_specific_headers(self):
        return []

    def _get_entries(self):
        if self._terse:
            if self._terse != "projects":
                raise EntityException("terse option with non-matching entity type")
            return ((p.Id,) for p in self._project_list)
        else:
            return ((p.Id, sanitise_string(p.Name)) for p in self._project_list)


class AppResultExtractor(EntityExtractor):
    def __init__(self, api, with_projects, terse, project_list, appresult_name):
        super(AppResultExtractor, self).__init__(api, with_projects, terse)
        self._project_list = project_list
        self._appresult_name = appresult_name

    def _get_specific_headers(self):
        return ["appresult id", "appresult name", "appsession name"]

    def _get_entries(self):
        for project in self._project_list:
            appresults = project.getAppResults(self._api)
            if self._appresult_name:
                appresults = [appresult for appresult in appresults if fnmatch.fnmatch(sanitise_string(appresult.Name), self._appresult_name)]
            for appresult in appresults:
                if self._terse == "appresults":
                    yield (appresult.Id,)
                elif self._with_projects:
                    if self._terse == "projects":
                        yield (project.Id,)
                    else:
                        yield (project.Id, sanitise_string(project.Name), appresult.Id, sanitise_string(appresult.Name), sanitise_string(appresult.AppSession.Name))
                else:
                    yield (appresult.Id, sanitise_string(appresult.Name), sanitise_string(appresult.AppSession.Name))


class AppResultFromAppSessionExtractor(EntityExtractor):
    def __init__(self, api, appsessions, terse):
        self._api = api
        self._appsessions = appsessions
        self._terse = terse
        self._with_projects = False

    def _get_specific_headers(self):
        return ["appresult id", "appresult name", "appsession name"]

    def _get_entries(self):
        for appsession in self._appsessions:
            ars = self._api.getAppSessionPropertyByName(appsession, 'Output.AppResults')
            for appresult_item in ars.Items:
                appresult = appresult_item.Content
                if self._terse:
                    yield (appresult.Id,)
                else:
                    yield (appresult.Id, sanitise_string(appresult.Name), sanitise_string(appresult.AppSession.Name))

class AppSessionExtractor(EntityExtractor):
    def __init__(self, api, with_projects, terse, status, extended, appsession_name, project_name=""):
        super(AppSessionExtractor, self).__init__(api, with_projects, terse)
        self._status = status
        self._extended = extended
        self._appsession_name = appsession_name
        self._project_name = project_name

    def _get_specific_headers(self):
        headers = ["appsession id", "appsession name", "appsession status"]
        if self._extended:
            headers.append("app inputs")
        return headers

    @staticmethod
    def _get_project_from_properties(properties):
        for property in properties.Items:
            if property.Name == "Output.Projects":
                try:
                    return property.Items[0]
                except:
                    raise EntityException("Cannot retrieve project","appsessions")
        raise EntityException("Cannot retrieve project","appsessions")

    def _get_details_from_properties(self, properties):
        input_names = []
        for property in properties.Items:
            if property.Name == "Input.Samples" or property.Name == "Input.AppResults":
                input_names.extend((item.Name for item in property.Items))
        if input_names:
            if len(input_names) > 3:
                contracted_names = input_names[:3] + ["%dmore" % (len(input_names) - 3)]
                input_name = "+".join(contracted_names)
            else:
                input_name = "+".join(input_names)
        else:
            input_name = "(unknown)"
        return input_name

    def _get_entries(self):
        userId = self._api.getUserById('current').Id
        qp_var = {
            "userCreatedBy": userId,
            "Status": self._status
        }
        # get additional information for appsessions if it's needed either for projects
        # or to render verbose output
        if self._with_projects or self._extended or self._project_name:
            qp_var['include'] = "Properties"
            qp_var['propertyFilters'] = "Output.Projects,Input.Samples,Input.AppResults"
        qp_object = qp(qp_var)
        appsessions = self._api.getAllAppSessions(qp_object)
        if self._appsession_name:
            appsessions = [appsession for appsession in appsessions if fnmatch.fnmatch(sanitise_string(appsession.Name), self._appsession_name)]
        for appsession in appsessions:
            if self._project_name:
                project = self._get_project_from_properties(appsession.Properties)
                if not fnmatch.fnmatch(sanitise_string(project.Name), self._project_name):
                    continue
            if self._terse == "appsessions":
                yield (appsession.Id,)
                continue
            row = [appsession.Id, sanitise_string(appsession.Name), appsession.Status]
            if self._with_projects:
                project = self._get_project_from_properties(appsession.Properties)
                if self._terse == "projects":
                    yield (project.Id, )
                    continue
                row = [ project.Id, sanitise_string(project.Name) ] + row
            if self._extended:
                input_name = self._get_details_from_properties(appsession.Properties)
                row.append(input_name)
            yield row


class TemplateExtractor(EntityExtractor):
    def __init__(self, api, with_projects, terse, id, appname, all_apps, app_options, template_manager):
        super(TemplateExtractor, self).__init__(api, with_projects, terse)
        self._id = id
        self._appname = appname
        self._all_apps = all_apps
        self._app_options = app_options
        self._template_manager = template_manager

    def _get_specific_headers(self):
        if self._all_apps:
            headers = ["appid", "appname", "appversion", "launchable"]
        elif self._app_options:
            headers = ["optionname", "type", "default"]
        else:
            headers = ["appid", "appname", "appversion", "source", "parameters"]
        return headers

    @staticmethod
    def app_launch_detail_generator(templates):
        for template in templates:
            launch_specification = LaunchSpecification(template.properties, template.defaults)
            yield (template.basespaceid, template.name, template.version, template.source,
                   launch_specification.format_minimum_requirements())

    def _get_entries(self):
        tm = self._template_manager
        if self._all_apps:
            apps = self._api.getApplications()
            if self._id:
                entries = ((app.Id, app.Name.encode('ascii', 'ignore'), app.VersionNumber, tm.has_basespaceid(app.Id)) for app in apps if self._id == app.Id)
            elif self._appname:
                entries = ((app.Id, app.Name.encode('ascii', 'ignore'), app.VersionNumber, tm.has_basespaceid(app.Id)) for app in apps if self._appname.lower() in app.Name.lower())
            else:
                entries = ((app.Id, app.Name.encode('ascii', 'ignore'), app.VersionNumber, tm.has_basespaceid(app.Id)) for app in apps)
        elif self._app_options:
            if self._id:
                template = tm.get_app_template_by_basespace_id(self._id)
            elif self._appname:
                templates = tm.get_app_templates_by_name(self._appname)
                if len(templates) == 0:
                    raise EntityException("No templates matching name: %s" % self._appname,"templates")
                elif len(templates) > 1:
                    raise EntityException("More than one template matching name: %s" % self._appname,"templates")
                template = templates[0]
            else:
                raise EntityException("Need to choose a single app to show options", "templates")
            launch_spec = LaunchSpecification(template.properties, template.defaults)
            entries = launch_spec.property_information_generator()
        else:
            if self._id:
                templates = [ tm.get_app_template_by_basespace_id(self._id) ]
            elif self._appname:
                templates = tm.get_app_templates_by_name(self._appname)
            else:
                templates = tm.get_all_templates()
            entries = self.app_launch_detail_generator(templates)
        return entries

class RunsExtractor(EntityExtractor):

    def __init__(self, api, with_projects, terse, extended):
        self._api = api
        self._with_projects = with_projects
        self._terse = terse
        self._extended = extended

    def _get_specific_headers(self):
        if self._extended:
            return ["runid", "run_name", "experiment_name", "instrument_name"]
        else:
            return ["runid", "run_name", "experiment_name"]

    def _get_entries(self):
        runs = self._api.getAccessibleRunsByUser()
        for run in runs:
            if self._terse:
                yield (run.Id,)
                continue
            if self._extended:
                yield (run.Id, run.Name, run.ExperimentName, run.InstrumentName)
            else:
                yield (run.Id, run.Name, run.ExperimentName)
