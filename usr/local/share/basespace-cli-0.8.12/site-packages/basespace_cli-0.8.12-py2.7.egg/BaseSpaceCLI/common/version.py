import argparse
import sys
import os
import re
import traceback
import subprocess
from collections import defaultdict

from cliff.command import Command

from .. import __console_width__,__version__,__build_number__,__build_date__


class VersionException(Exception):
    def __init__(self, msg):
        self.parameter = "Version-related Error: " + str(msg)

    def __str__(self):
        return self.parameter


class VersionAction(argparse.Action):
    version = __version__
    build_number = __build_number__
    build_date = __build_date__

    def __call__(self, parser, namespace, values, option_string=None):
        app = self.default
        app.stdout.write( 'BaseSpace CLI {0}.{1}  (built on {2})\n'.format( self.version,
                                                                            self.build_number,
                                                                            self.build_date ))
#        sys.exit(0)


class VersionCommand(Command):
    """print detailed version for another command
    """

    def get_parser(self, prog_name):
        parser = super(VersionCommand, self).get_parser(prog_name)
        parser.add_argument('cmd',
                            nargs='*',
                            help='name of the command',
                            )
        return parser

    def take_action(self, parsed_args):
        action = VersionAction(None, None, default=self.app)
        action(self.app.parser, self.app.parser, None, None)
        if parsed_args.cmd:
            try:
                the_cmd = self.app.command_manager.find_command(
                    parsed_args.cmd,
                )
                cmd_factory, cmd_name, search_args = the_cmd
            except ValueError:
                # Did not find an exact match
                cmd = parsed_args.cmd[0]
                fuzzy_matches = [k[0] for k in self.app.command_manager
                                 if k[0].startswith(cmd)
                                 ]
                if not fuzzy_matches:
                    raise
                self.app.stdout.write('Command "%s" matches:\n' % cmd)
                for fm in sorted(fuzzy_matches):
                    self.app.stdout.write('  %s\n' % fm)
                return
            self.app_args.cmd = search_args
            #cmd = cmd_factory(self.app, self.app_args)
            path = cmd_factory.path
            option = ('-V' if '-V' in sys.argv
                           else ('--version' if '--version' in sys.argv
                                             else ('--version' if 'version' == sys.argv[1]
                                                               else "N/A"
                                                  )
                                )
                     )
            if option == "N/A":
                raise VersionException("Could not figure out whether short of long option has been used.")
            version_cmd = [path, option]
            try:
                proc = subprocess.Popen( version_cmd,
                                         stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE )
            except OSError as e:
                raise VersionException( "Could not execute '%s': %s"
                                      % (version_cmd[0], e) )

            out,err = proc.communicate()
            if err:
                raise VersionException( "There was a problem retrieving version from sub-command.\n"
                                        "%sDoes '%s' implement either '-V' or '--version'?\n"
                                        " *** %s"
                                      % (' ' * 10, version_cmd[0], err) )
            self.app.stdout.write( out )
            #self.app.stdout.write( "\n" )
        return 0


