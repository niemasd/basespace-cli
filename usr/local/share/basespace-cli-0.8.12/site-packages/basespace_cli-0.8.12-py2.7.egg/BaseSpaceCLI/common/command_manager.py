import os
import logging
import pkg_resources

from cliff.commandmanager import CommandManager

from .plugin_manager import Plugin,PluginManager
from ..tools.registry import ThirdParty



class DualCommandManager(CommandManager):
    """ Extends a CommandManager, so that we can store inverted combinations
        and decide which tools are visible and not
    """

    log = logging.getLogger(__name__)
    config_path = None

    def __init__(self, basespace_dir, convert_underscores=True):
        super(DualCommandManager,self).__init__( '', convert_underscores )
        if not os.path.exists(basespace_dir):
            os.mkdir(basespace_dir, 0700)

    def set_config(self,config_path):
        self.config_path = config_path

    # this hack will force it not to auto-load the commands at initialization
    def _load_commands(self):
        pass

    def _get_executable(self,entry_point):
        if hasattr(entry_point, 'extras') and entry_point.extras:
            for p in os.environ['PATH'].split(':'):
                exe = os.path.join(p, entry_point.extras[0])
                if os.access(exe, os.X_OK):
                    return exe
        return None

    def _load(self,entry_point):
        return entry_point.load(require=False)

    def load_commands(self, namespace, visible=False):
        """Load all the commands from an entrypoint"""
        for ep in pkg_resources.iter_entry_points(namespace):
            self.add_dual_command( namespace, ep.name, self._load(ep), self._get_executable(ep), visible=visible )
        return

    def load_from_file(self):
        pm = PluginManager(self.config_path)
        plugins = pm.load()
        for group,plugin in plugins.iteritems():
            for name,plugin in plugin.iteritems():
                path = plugin["path"]
                if not os.access(path,os.X_OK):
                    self.log.warning("Plugin '%s' points to a non-executable path: %s",name,path)
                    path = None
                self.add_dual_command( str(group), str(name), ThirdParty, path, plugin.get("description") )

    def add_dual_command(self, namespace, name, cmd_class, path=None, desc=None, visible=False):
        cmd_name = (name.replace('_', ' ')
                    if self.convert_underscores
                    else name)
        self.add_command( cmd_name, cmd_class, path, desc, visible )
        words = cmd_name.split()
        if len(words) == 2:
            self.add_command( ' '.join([words[1],words[0]]), cmd_class, path, desc )

    def add_command(self, name, command_class, path=None, desc=None, visible=False):
        self.commands[name] = Plugin(name, command_class, path, desc, visible)

    def __getitem__(self,key):
        return self.commands[key]

    @property
    def __visible__(self):
        """Analoguous to __iter__, but for visible commands only"""
        return iter([cmd  for cmd in self.commands.items()  if cmd[1].is_visible()])

    def make_visible(self, name):
        self.commands[name].visible = True
