
import os
import logging

from ..tools.complete import Complete


class Buffer:
    def __init__(self):
        self.content = []

    def write(self, text):
        self.content.append(text)

    def read_all(self, sep=""):
        return sep.join(self.content)


class BashCompletion(object):
    """class to manage tab-completion functionality"""
    
    triggers = ['Authenticate','Complete','HelpCommand','Register','Unregister']
    entities = ['samples','projects','appsessions','appresults','apps']

    def __init__(self,basespace_dir):
        self.bash_completion = os.path.join(os.path.expanduser("~"), ".bash_completion")
        self.completion_bash = os.path.join(basespace_dir,"completion.bash")
        self.log = logging.getLogger(self.bash_completion)

    def write(self,app):
        factory = app.command_manager['complete'].load()
        complete_buffer = Buffer()
        complete_cmd = factory(app, app.options, output=complete_buffer)
        complete_parser = complete_cmd.get_parser('complete')
        parsed_args = complete_parser.parse_args([])
        complete_cmd.run(parsed_args)
        if complete_buffer.content:
            header  = complete_buffer.content[0].split("\n")
            trailer = complete_buffer.content[-1].split("\n")
            invocation = trailer[-2].split(" ")

            # changing bash's Internal Field Separator
            header.insert(3,"  IFS=$'\\n'")
            # inserting comp-options to the line where complete is being invoked
            trailer[-2] = " ".join( [invocation[0],'-o','filenames'] + invocation[1:] )

            complete_buffer.content[0] = "\n".join( header )
            list_completion_lines = []
            for i,_ in enumerate(complete_buffer.content):
                if i!=0 and i!=(len(complete_buffer.content)-1):
                    content = complete_buffer.content[i]
                    if "cmds_list" in content:
                        switches = content[content.index("=")+1:]
                        list_line = "  cmds_list=$'%s'\n" % ("\\n".join(self.entities))
                        list_completion_lines.append(list_line)
                        for entity in self.entities:
                            entity_line = "  cmds_list_%s=$%s" % (entity, switches)
                            list_completion_lines.append(entity_line)
                        complete_buffer.content[i] = ""
                        continue
                    if content:
                        complete_buffer.content[i] = content.replace("=","=$")
            complete_buffer.content[-2:-2] = list_completion_lines
            complete_buffer.content[-1] = "\n".join( trailer )
            with open(self.completion_bash,'w') as fh:
                fh.write( complete_buffer.read_all() )
        else:
            self.log.warning( "Could not generate: %s" % self.completion_bash )

    def enable(self):
        entry = "[ -r %s ] && source %s" % (self.completion_bash,self.completion_bash)
        msg = "Please run 'exec bash', or open a new terminal, to activate tab-completion"
        try:
            with open(self.bash_completion,'r+') as fh:
                found = any( line.startswith(entry)  for line in fh )
                if not found:
                    fh.write( '\n' + entry + '\n' )
                    self.log.warning( "'%s' has changed. %s." % (self.bash_completion, msg) )
        except IOError:
            with open(self.bash_completion,'w') as fh:
                fh.write( entry + '\n' )
            self.log.warning( "New '%s' found. %s." % (self.bash_completion, msg) )
