import os
import sys
import logging
import subprocess
import argparse
import signal

from cliff.command import Command
from cliff.lister import Lister
from cliff.display import DisplayCommandBase

from BaseSpacePy.api.BaseSpaceAPI import BaseSpaceAPI

from .. import __version__, __api_timeout__
from .streams import IoStreams
from .parsers import ExternalParser
from .help import SubHelpFormatter


class BaseCommand(Command):

    def __init__(self, app, app_args, cmd_name=__name__):
        super(BaseCommand, self).__init__( app, app_args,
                                           ".".join( [__package__.split(".")[0],
                                                      cmd_name]  ))
        self.log = logging.getLogger(self.cmd_name)
        self.path = None


class CommandWithAPI(BaseCommand):
    """Base class for python-based command plugins.

    :param app: Application instance invoking the command.
    :paramtype app: cliff.app.App
    """
    api  = None

    def __init__(self, app, app_args, cmd_name=__name__, ver=None, declare_api=True):
        super(CommandWithAPI, self).__init__( app, app_args, cmd_name )
        self.full_name = "/".join( [self.cmd_name, ver or __version__] )
        self._api = None

    def get_parser(self, prog_name):
        parents = [self.app.parser]
        if self.app.additional_parsers:
            parents.extend(self.app.additional_parsers)
        parser =  argparse.ArgumentParser(
            description=self.get_description(),
            prog=prog_name,
            parents=parents,
            conflict_handler='resolve',
            add_help=False,
        )
        return parser

    @property
    def api(self):
        if not self._api:
            if self.app.options.config:
                self._api = BaseSpaceAPI( userAgent=self.full_name,
                                         verbose=self.app.very_verbose(),
                                         profile=self.app.options.config,
                                         timeout=__api_timeout__ )
            else:
                self._api = BaseSpaceAPI( userAgent=self.full_name,
                                         verbose=self.app.very_verbose(),
                                         timeout=__api_timeout__ )
        return self._api


###############################################################################################


class ExternalCommand(BaseCommand):
    """Base class for non-python command plugins.

    :param app: Application instance invoking the command.
    :paramtype app: cliff.app.App
    """

    def __init__(self, cmd, app, app_args, cmd_name=__name__):
        super(ExternalCommand, self).__init__( app, app_args, cmd_name )
        if cmd:
            if isinstance(cmd,list):
                self.cmd = cmd
            else:
                self.cmd = [cmd]
            # put back the ones that have been consumed already
            if self.app.options.verbose_level<1:
                self._propagate('--quiet','-q')
            if self.app.options.verbose_level>1:
                for i in xrange(1,self.app.options.verbose_level):
                    self._propagate('--verbose','-v')
            if self.app.options.dry_run:
                self._propagate('--dry-run')
            if self.app.options.config != "default":
                self._propagate('--config','-c',self.app.options.config)
        else:
            self.cmd = ["echo","*** '%s' does not support '%s' ***" % (sys.argv[0],self.cmd_name)]
        return

    def run(self, parsed_args):
        "Invoked by the application when the command is run."
        return self.take_action(parsed_args)

    def _propagate(self,long,short=None,content=None):
        for arg in sys.argv:
            if arg.startswith(long):
                if content:
                    self.cmd.extend(["=".join([long,content])])    # --arg=cont
                else:
                    self.cmd.extend([long])                        # --arg
            elif arg.startswith("-"):
                if short[1] in arg:
                    self.cmd.extend([short])                       # -a
                    if content:
                        self.cmd.extend([content])                 # -a cont


    def get_parser(self, prog_name):
        parser = ExternalParser(
            command=self.cmd[0],
            description=self.get_description(),
            prog=prog_name,
        )
        return parser


    def take_action(self, unparsed_args):
        cmd = self.cmd
        if self.cmd[0] != "echo":
            cmd.extend(unparsed_args)
        self.log.debug("Underlying command: %s", cmd)
        try:
            proc = subprocess.Popen( cmd )#,
                                    # stdin=subprocess.PIPE,
                                    # stdout=subprocess.PIPE,
                                    # stderr=subprocess.PIPE )
        except OSError as err:
            self.log.error( "Could not execute %s. Is '%s' missing a shebang line?", cmd, os.path.basename(cmd[0]) )
            self.log.debug(err)
            return err.errno
        s = IoStreams(proc)
        def signal_handler(signal,frame):
            self.log.warning("Keyboard Interrupt (Ctrl+C) detected... waiting for process (PID=%d) to finish", proc.pid)
            if proc.poll() is not None:
                proc.wait()
        signal.signal(signal.SIGINT,signal_handler)
        while True:
            try:
                item = s.get()
            except s.empty():
                if proc.poll() is not None:
                    break
            else:
                id, line = item
                if s.all_closed(id):
                    break
                elif s.is_out(id):
                    self.log.info(line.rstrip())
                elif s.is_err(id):
                    self.log.error(line.rstrip())
        proc.wait()
        return proc.returncode


class InternalCommand(CommandWithAPI):
    """Base class for python-based command plugins.

    :param app: Application instance invoking the command.
    :paramtype app: cliff.app.App
    """

    def get_parser(self, prog_name):
        parser = super(InternalCommand,self).get_parser(prog_name)
        parser.formatter_class=SubHelpFormatter
        return parser

    def run(self, parsed_args):
        "Invoked by the application when the command is run."
        return self.take_action(parsed_args)


class InternalListerCommand(CommandWithAPI,Lister):
    """Base class for python-based commands that list stuff.

    :param app: Application instance invoking the command.
    :paramtype app: cliff.app.App
    """

    def __init__(self, app, app_args, cmd_name=__name__, ver=None, declare_api=True):
        super(InternalListerCommand, self).__init__( app, app_args,cmd_name,ver,declare_api)


    def get_parser(self, prog_name):
        parser = super(InternalListerCommand,self).get_parser(prog_name)
        parser.formatter_class=SubHelpFormatter
        formatter_group = parser.add_argument_group(
            title='output formatters',
            description='',
        )
        formatter_choices = sorted(self._formatter_plugins.names())
        formatter_default = self.formatter_default
        if formatter_default not in formatter_choices:
            formatter_default = formatter_choices[0]
        formatter_group.add_argument(
            '-f', '--format',
            dest='formatter',
            action='store',
            choices=formatter_choices,
            default=formatter_default,
            help='the output format, defaults to %s' % formatter_default,
        )
        formatter_group.add_argument(
            '-C', '--column',
            action='append',
            default=[],
            dest='columns',
            metavar='COLUMN',
            help='specify the column(s) to include, can be repeated',
        )
        for formatter in self._formatter_plugins:
            formatter.obj.add_argument_group(parser)
        return parser

