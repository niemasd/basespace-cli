import os
import sys
import subprocess

from argparse import ArgumentParser,ArgumentError,SUPPRESS

from .help import HelpFormatter


class ParserException(Exception):
    def __init__(self, type, value):
        self.parameter = ("Error parsing %s command: " % type) + str(value)

    def __str__(self):
        return repr(self.parameter)

class ExternalException(ParserException):
    def __init__(self, value):
        super(ExternalException,self).__init__("external",value)

class InternalException(ParserException):
    def __init__(self, value):
        super(InternalException,self).__init__("internal",value)


class ExternalParser(ArgumentParser):

    def __init__(self,
                 command,
                 prog=None,
                 usage=None,
                 description=None,
                 epilog=None,
                 version=None,
                 parents=[],
                 formatter_class=HelpFormatter,
                 prefix_chars='-',
                 fromfile_prefix_chars=None,
                 argument_default=None,
                 conflict_handler='error',
                 add_help=True):
        super(ExternalParser, self).__init__( prog, usage, description, epilog, version, parents,
                                              formatter_class, prefix_chars, fromfile_prefix_chars,
                                              argument_default, conflict_handler, add_help )
        self.cmd = [ str(command) ]
        return


    def format_help(self):
         help_cmd = self.cmd
         if help_cmd[0] == "echo":
             help_cmd.append('!! no help available !!')
         elif '-h' in sys.argv:
             help_cmd.append('-h')
         elif '--help' in sys.argv:
             help_cmd.append('--help')
         elif 'help' == sys.argv[1]:
             help_cmd.append('--help')
         else:
             raise ExternalException("Unrecognized HELP command")
         try:
             proc = subprocess.Popen( help_cmd,
                                      stdout=subprocess.PIPE,
                                      stderr=subprocess.PIPE )
         except OSError:
             raise ExternalException( "Could not execute '%s'. Is '%s' missing a shebang line?"
                                    % (help_cmd, os.path.basename(help_cmd[0])) )

         out,err = proc.communicate()
         if err:
             raise ExternalException( "There was a problem retrieving help from sub-command."
                                      " Does '%s' implement either '-h' or '--help'? \n*** %s"
                                    % (help_cmd, err) )
         return out


    def parse_args(self, args=None, namespace=None):
        # this could be quite confusing: we are using parse_known_args() to return the "unknown" ones (hence [1])
        return self.parse_known_args(args, namespace)[1]



class RegistryParser(ArgumentParser):

    def __init__(self,
                 prog=None,
                 usage=None,
                 description=None,
                 epilog=None,
                 version=None,
                 parents=[],
                 formatter_class=HelpFormatter,
                 prefix_chars='-',
                 fromfile_prefix_chars=None,
                 argument_default=None,
                 conflict_handler='error',
                 add_help=True):
        super(RegistryParser, self).__init__( prog, usage, description, epilog, version, parents,
                                              formatter_class, prefix_chars, fromfile_prefix_chars,
                                              argument_default, conflict_handler, add_help )
        # TODO: there has to be a way to derive this using pkg_resources
        self.forbidden = ["builtin","alias","discoverable"]
        return

    def _check_value(self, action, value):
        from gettext import gettext as _
        # converted value must NOT be one of the choices (if specified)
        if action.choices is not None and value in action.choices:
            tup = value, ', '.join(map(repr, action.choices))
            msg = _('invalid choice: %r (the following groups are restricted: %s)') % tup
            raise ArgumentError(action, msg)



class ProjectParser(ArgumentParser):
    def __init__(self):
        super(ProjectParser,self).__init__(add_help=False)


class SampleParser(ArgumentParser):
    def __init__(self):
        super(SampleParser,self).__init__(add_help=False)
        self.add_argument( '-P', '--with-properties', dest="with_properties", action="store_true", default=False,
                           help="display properties" )
        self.add_argument('--sample-name', help='select on sample name (by glob)')


class AppresultParser(ArgumentParser):
    def __init__(self):
        super(AppresultParser,self).__init__(add_help=False)
        self.add_argument('--appresult-name', help='select on appresult name (by glob)')


class AppsessionParser(ArgumentParser):
    all_status = ["Running", "Complete", "AwaitingAuthorization", "Aborting", "Aborted", "PendingExecution", "Pending"]
    default_status = ["Running", "PendingExecution"]

    def __init__(self):
        super(AppsessionParser,self).__init__(add_help=False)
        self.add_argument('-x', '--extended-columns', dest='extended', default=False, action="store_true",
                          help="add column for app input")
        self.add_argument('-u', '--status', dest="status", choices=self.all_status, nargs='*', metavar="STATUS",
                          default=self.default_status,
                          help="S|filter-by list of statuses. Valid statuses are:\n%s\n(defaults to: %s)"
                              %(self.all_status, self.default_status))
        self.add_argument('--appsession-name', help='select on appsession name (by glob)')


class TemplateParser(ArgumentParser):
    def __init__(self):
        super(TemplateParser,self).__init__(add_help=False)
        self.add_argument('-i', '--id', type=str, dest="id", help='basespace id of app')
        self.add_argument('-n', '--appname', dest="appname", help="name of app")
        self.add_argument('--all-apps', dest="all_apps", action="store_true", default=False,
                          help="show all BaseSpace apps with a flag for whether they are currently launchable")
        self.add_argument('--app-options', dest="app_options", action="store_true", default=False,
                          help="show additional options for app")
        self.add_argument('--project-name', help=SUPPRESS)

class RunsParser(ArgumentParser):
    def __init__(self):
        super(RunsParser,self).__init__(add_help=False)
        self.add_argument('-x', '--extended-columns', dest='extended', default=False, action="store_true",
                          help="add additional columns")
