"""
add a new template into the local BaseSpace CHUK API database
there should be a number of ways to do this:

    - with a manually derived template (*)
    - by querying a BaseSpace app session and automatically deriving the template from this
    - by query the app directly to get the template

Those marked with a (*) are supported.

In each case, there is some parsing of the template to derive the variables used so that these can be listed with the app;
"""

import os
import json
import pkgutil
import pprint


from BaseSpacePy.api.AppLaunchHelpers import AppSessionMetaDataSDK, AppSessionMetaDataRaw
from BaseSpacePy.api.BaseMountInterface import BaseMountInterface

from ..common.template_manager import TemplateManager, TemplateManagerException
from ..common.interface import InternalCommand


class AddNewTemplateException(Exception):
    pass

"""
There are several ways to add new app launch templates

1. A manually specified ap. this requires the properties (-p) (json file), defaults (-e) (json file),
   appname (-n) and app ID (-i)
2. Via an appsession ID (-a). It will use the Python SDK to pull down the appsession and derive a template
3. Via a BaseMount path (-m). Uses the path to get the appsession details and uses this to derive a template
4. Via a json file containing a list of templates (-j). This can be provided, for example, by LaunchSpace.

Only use one of these methods at a time!
"""

class AddNewTemplate(InternalCommand):
    "import a new app for launch"

    __category__ = "Apps"

    def __init__(self, app, app_args, cmd_name=None):
        super(AddNewTemplate, self).__init__(app, app_args, self.__class__.__name__)
        return

    def process_manually_specified_template(self, args):
        if not os.path.exists(args.properties_file):
            raise AddNewTemplateException("missing file: %s" % args.properties_file)
        try:
            pstr = open(args.properties_file).read()
        except Exception as e:
            raise AddNewTemplateException("could not read properties file: (%s)" % str(e))
        try:
            properties = json.loads(pstr)
        except ValueError as e:
            raise AddNewTemplateException("could not parse defaults json file: %s (%s)" % (args.defaults, str(e)))
        if args.defaults:
            if not os.path.exists(args.defaults):
                raise AddNewTemplateException("missing file: %s" % args.defaults_file)
            defaults_str = open(args.defaults).read()
            try:
                defaults = json.loads(defaults_str)
            except ValueError as e:
                raise AddNewTemplateException("could not parse defaults json file: %s (%s)" % (args.defaults, str(e)))
        else:
            defaults = {}
        app_name = os.path.basename(args.properties_file).replace(".json", "")
        if args.id:
            app_id = args.id
        else:
            raise AddNewTemplateException("must provide an app ID with manual template creation")

        if args.version:
            version = args.version
        else:
            raise AddNewTemplateException("must provide an app version with manual template creation")

        return app_name, app_id, version, properties, defaults


    def process_appsession_template(self, args, verbose_level):
        # first, get the appsession metadata,
        # either from BaseSpace via the Python SDK:
        if args.appsession_id:
            appsession_metadata = AppSessionMetaDataSDK(self.api.getAppSessionById(args.appsession_id))
        # or from the BaseMount cached metadata
        elif args.appsession_path:
            mbi = BaseMountInterface(args.appsession_path)
            if mbi.type != "appsession":
                raise Exception("Specified wrong type of BaseMount path: %s" % mbi.type)
            appsession_metadata = AppSessionMetaDataRaw(mbi.get_meta_data())
        else:
            raise AddNewTemplateException("must specify either a file containing properties (-p), an appsession id (-a) or an appsession_path in BaseMount(-m)")
        properties, defaults = appsession_metadata.get_refined_appsession_properties()
        # and a name for the app
        app_name = appsession_metadata.get_app_name()
        app_id = appsession_metadata.get_app_id()
        app_version = appsession_metadata.get_app_version()
        # finally, turn the properties and defaults into strings
        if verbose_level > 1:
            pprint.pprint(properties)
            pprint.pprint(defaults)
        return app_name, app_id, app_version, properties, defaults


    def get_parser(self, prog_name):
        parser = super(AddNewTemplate, self).get_parser(prog_name)
        parser.add_argument('-i', '--appid', type=str, dest="id", default="", help='basespace id of app')
        parser.add_argument('-n', '--appname', dest="appname", help="name of app")
        parser.add_argument('-p', '--properties-file', dest="properties_file", help='file containing properties for app')
        parser.add_argument('-e', '--defaults-file', dest="defaults_file", help='file containing default values for app')
        parser.add_argument('-a', '--appsession-id', dest="appsession_id", help='app session ID to use to derive a template')
        parser.add_argument('-r', '--appversion', dest="appversion", help='app version number')
        parser.add_argument('-m', '--appsession-path', dest='appsession_path', help='BaseMount path to an appsession')
        parser.add_argument('-j', '--input-templates', dest='input_templates', help='json file containing templates to add')
        parser.add_argument('-f', '--force', dest="force", action="store_true", default=False, help='force import of template, even if one exists')
        return parser

    def take_action(self, parsed_args):

        app_name = ""
        app_id = ""

        tm = TemplateManager(self.app.config_path, self.api)

        # this block is for json-file specified templates
        if parsed_args.input_templates:
            if parsed_args.appsession_path or parsed_args.id or parsed_args.appsession_id:
                raise AddNewTemplateException("found both a file from which to import templates and individual app details!")
            if not os.access(parsed_args.input_templates, os.R_OK):
                raise AddNewTemplateException("could not read template file: %s" % parsed_args.input_templates)
            with open(parsed_args.input_templates) as fh:
                try:
                    all_templates = json.load(fh)
                except ValueError as e:
                    raise AddNewTemplateException("could not decode template file: %s" % parsed_args.input_templates)
                tm.unpack_all_templates(all_templates, force=parsed_args.force)
        else:
            # this block is for manually entered app details, as in point (1) of the documentation above
            if parsed_args.properties_file:
                # this block is for appsession derived app templates, either via the Python SDK or from BaseMount
                app_name, app_id, app_version, properties, defaults = self.process_manually_specified_template(parsed_args)
            else:
                app_name, app_id, app_version, properties, defaults = self.process_appsession_template(parsed_args, self.app.options.verbose_level)
            if parsed_args.appname:
                # this is an override - we attempt to infer the app name in all the other cases above
                app_name = parsed_args.appname

            if not app_id:
                raise AddNewTemplateException("app_id must be provided or obtained from an appsession!")

            if not self.app.options.dry_run:
                tm.add_app_template(
                    name=app_name,
                    basespaceid=app_id,
                    version=app_version,
                    properties=properties,
                    defaults=defaults,
                    force=parsed_args.force
                )
