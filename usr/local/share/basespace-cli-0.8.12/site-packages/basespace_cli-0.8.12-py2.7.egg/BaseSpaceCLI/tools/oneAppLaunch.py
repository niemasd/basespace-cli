# Copyright (c) 2015 Illumina, Inc.
#
# This software is provided under the terms and conditions of the
# Illumina Open Source Software License 1.
#
# You should have received a copy of the Illumina Open Source
# Software License 1 along with this program. If not, see
# <https://github.com/sequencing/licenses/> 
#

"""
Launches a BaseSpace app.

Uses an app launch json template, which is passed on the command line or otherwise pulled from a service that provides these

"""

import json
import os
import copy
import pkgutil

from BaseSpacePy.api.BaseSpaceAPI import BaseSpaceAPI
from BaseSpacePy.api.BaseSpaceException import ServerResponseException
from BaseSpacePy.api.AppLaunchHelpers import LaunchSpecification, LaunchPayload

from ..common.template_manager import TemplateManager
from ..common.interface import InternalCommand
from .. import __log_terse_level__


def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in xrange(0, len(l), n):
        yield l[i:i + n]


class AppLaunchException(Exception):
    pass


class OneAppLaunch(InternalCommand):
    "launch an app."

    __category__ = "Apps"

    def __init__(self, app, app_args, cmd_name=None):
        super(OneAppLaunch, self).__init__(app, app_args, self.__class__.__name__)
        return

    def get_parser(self, prog_name):
        parser = super(OneAppLaunch, self).get_parser(prog_name)
        parser.add_argument('-i', '--appid', type=str, dest="appid", help='basespace id of app')
        parser.add_argument('-a', '--agentid', type=str, dest="agentid", default="",
                            help='agent id to pass with the launch payload')
        parser.add_argument('-b', '--batch-size', dest="batch_size",
                            help="for long lists of inputs, break them up into batches of size b")
        parser.add_argument('-n', '--appname', type=str, dest="appname", help='substring matching app name')
        parser.add_argument('-o', '--option', type=str, dest="option", action="append", default=[],
                            help="set optional variables for app launch in the form var:val. Can be used many times.")
        parser.add_argument('-s', '--sample-attributes', type=str, dest="sample_attributes", action="append",
                            default=[], help="sample attributes for each sample in the form var:val")
        parser.add_argument('--disable-consistency-checking', action="store_true", default=False,
                            help="disable checking consistency between launch access token and any BaseMount path tokens")
        parser.add_argument('--launch-name', type=str, help="appsession name. Use %%d to include the batch number")
        parser.add_argument('launch_parameters', nargs='*', help='compulsory parameters for app launch')
        return parser

    def take_action(self, parsed_args):
        if not parsed_args.appid and not parsed_args.appname:
            raise Exception(
                "must specify appid or appname")  ## this should be of type ArgumentMissing or something like that

        tm = TemplateManager(self.app.config_path, self.api)
        api_version = self.api.version
        ########
        # figure out the app template details by looking them up in a store of templates
        app_name = ""
        app_id = ""
        if parsed_args.appid:
            app_id = parsed_args.appid
            app_template = tm.get_app_template_by_basespace_id(parsed_args.appid)
        else:
            assert parsed_args.appname
            app_templates = tm.get_app_templates_by_name(parsed_args.appname)
            if len(app_templates) == 0:
                raise AppLaunchException("Could not find app with name: %s" % parsed_args.appname)
            if len(app_templates) > 1:
                app_names = ",".join((app_template.name for app_template in app_templates))
                raise AppLaunchException(
                    "More than one app matching name: %s (%s)" % (parsed_args.appname, app_names))
            app_template = app_templates[0]
        properties = app_template.properties
        defaults = app_template.defaults
        app_name = app_template.name
        app_id = app_template.basespaceid

        ###
        # now that we've got the template details, process them into useful objects

        launch_spec = LaunchSpecification(properties, defaults)

        # turn the config variables provided into a dictionary
        constants = dict((varpair.split(":") for varpair in parsed_args.option))
        sample_attributes = dict((attrpair.split(":") for attrpair in parsed_args.sample_attributes))

        # get the minimum requirements for the launch
        minimum_requirements = launch_spec.get_minimum_requirements()

        # check we have the right numer of arguments
        if len(parsed_args.launch_parameters) != len(minimum_requirements):
            self.log.error("Wrong number of variables specified!")
            minimum_requirements_str = launch_spec.format_minimum_requirements()
            self.log.error("App \"%s\" needs %d arguments (%s)"
                           % (app_name, len(minimum_requirements), minimum_requirements_str))
            if self.app.options.verbose_level > 1:
                self.log.error("optional arguments:")
                self.log.error(launch_spec.format_property_information())
            return 1

        # fold in the positional arguments

        if parsed_args.batch_size and launch_spec.count_list_properties() > 1:
            raise AppLaunchException("cannot specify a batch size where app requires more than one list property")

        # build a list of argument lists
        # this is for batching; each entry in this list will be a call signature to an app
        # for batching, all the arguments to each call will be the same except the list of core input data
        # such as samples or appresults
        arg_lists = [list()]
        for i, param in enumerate(parsed_args.launch_parameters):
            varname = minimum_requirements[i]
            # for project parameters try to get it by name and resolve this to an ID
            if launch_spec.get_property_bald_type(varname) == "project" and not os.path.exists(param):
                try:
                    proj = self.api.getUserProjectByName(param)
                    param = proj.Id
                except ServerResponseException:
                    pass
            processed_param = launch_spec.process_parameter(param, varname)

            if parsed_args.batch_size and launch_spec.is_list_property(varname):
                assert len(arg_lists) == 1
                base_args = arg_lists.pop()
                for batch in chunks(processed_param, int(parsed_args.batch_size)):
                    arg_list = copy.copy(base_args)
                    arg_list.append(batch)
                    arg_lists.append(arg_list)
            else:
                for arg_list in arg_lists:
                    arg_list.append(processed_param)

        # make a launch payload for each argument list
        # the LaunchPayload objects have various convenience methods to process and prepare these to launch apps
        launch_payloads = [
            LaunchPayload(launch_spec, arg_list, constants, self.api, parsed_args.disable_consistency_checking) for
            arg_list in arg_lists]

        for (batch_number, launch_payload) in enumerate(launch_payloads):
            if parsed_args.launch_name:
                try:
                    launch_name = parsed_args.launch_name % batch_number
                except TypeError:
                    launch_name = parsed_args.launch_name
            else:
                launch_name = launch_payload.derive_launch_name(app_name)

            variables = launch_payload.get_all_variables()
            launch_json = launch_spec.make_launch_json(variables, launch_name, api_version, sample_attributes,
                                                       parsed_args.agentid)

            if self.app.options.dry_run:
                self.log.info("would launch app %s (%s)" % (app_name, app_id))
                self.log.info("with launch name: %s" % launch_name)
                self.log.info("payload:")
                if self.app.options.verbose_level >= 2:
                    self.log.info(json.dumps(json.loads(launch_json), indent=4))
                else:
                    self.log.info(launch_json)
            else:
                response = self.api.launchApp(app_id, launch_json)
                if self.app.options.terse:
                    self.log.log(__log_terse_level__, "%s" % response.Id)
                else:
                    self.log.info("%s (%s)" % (response, response.Id))
