#
# Copyright (c) 2015 Illumina, Inc.
#
# This software is provided under the terms and conditions of the
# Illumina Open Source Software License 1.
#
# You should have received a copy of the Illumina Open Source
# Software License 1 along with this program. If not, see
# <https://github.com/sequencing/licenses/>
#

from time import sleep
from ..common.interface import InternalListerCommand
from ..common.entities import AppResultFromAppSessionExtractor


class WaitException(Exception):
    pass


class Wait(InternalListerCommand):
    "wait for appsessions to finish, and then convert them into the generated appresults"

    __category__ = "Creating and listing"

    WAIT_STATUSES = [
        "PendingExecution",
        "Pending",
        "Initializing",
        "Running"
    ]

    FINISH_STATUS = "Complete"

    FAILED_STATUSES = [ "Aborted", "Error", "Aborting" ]

    def __init__(self, app, app_args, cmd_name=None):
        super(Wait, self).__init__(app, app_args, self.__class__.__name__)
        return

    def get_parser(self, prog_name):
        parser = super(Wait, self).get_parser(prog_name)
        parser.add_argument('-i', '--interval', type=float, dest="interval", default=60,
                            help='polling interval (seconds)')
        parser.add_argument('--ignore-failed', action="store_true", default=False,
                            help='skip over failed appsessions, instead of exiting with an error')
        parser.add_argument('appsessionids', nargs='+', type=str, help='appsessions to convert into appresults')
        return parser

    def _get_appsession_status(self, appsessionid):
        appsession = self.api.getAppSessionById(appsessionid)
        return appsession.Status

    def _get_appsession_statuses(self, appsession_ids):
        return dict(((appsess_id, self._get_appsession_status(appsess_id)) for appsess_id in appsession_ids))

    def take_action(self, parsed_args):
        appsessionids = []
        for entry in parsed_args.appsessionids:
            if entry.startswith("@"):
                appsessionids.extend((line.strip() for line in open(entry[1:])))
            else:
                appsessionids.append(entry)
        # check status of appsessions
        appsession_status = self._get_appsession_statuses(appsessionids)
        while any((status != self.FINISH_STATUS for status in appsession_status.values())):
            for appsess_id, status in appsession_status.iteritems():
                if status != self.FINISH_STATUS:
                    if status in self.FAILED_STATUSES:
                        if parsed_args.ignore_failed:
                            self.log.warning("Skipping failed AppSession: %s" % appsess_id)
                            appsessionids.remove(appsess_id)
                            continue
                        else:
                            raise WaitException("AppSession failed: %s" % appsess_id)
                    if status not in self.WAIT_STATUSES:
                        raise WaitException("Unrecognised AppSession status: (%s, %s)" % (appsess_id, status))
            # at this stage, we might have trimmed the list a little by some failed appsessions
            # check if we only have FINISHED apps left. If we don't, wait a while before going around again.
            if not appsessionids or all((appsession_status[appsession_id] == self.FINISH_STATUS for appsession_id in appsessionids)):
                break
            sleep(parsed_args.interval)
            appsession_status = self._get_appsession_statuses(appsessionids)

        if self.app.options.terse:
            # this is a bit of a hack,
            # because I can't inject the formatter decision up high enough to get this selected properly
            self.formatter = self._formatter_plugins["value"].obj
        are = AppResultFromAppSessionExtractor(self.api, appsessionids, self.app.options.terse)
        return are.get_header_and_entries()
