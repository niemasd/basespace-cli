#
# Copyright (c) 2015 Illumina, Inc.
#
# This software is provided under the terms and conditions of the
# Illumina Open Source Software License 1.
#
# You should have received a copy of the Illumina Open Source
# Software License 1 along with this program. If not, see
# <https://github.com/sequencing/licenses/> 
#


"""
Uploads a (FASTQ) sample into BaseSpace.

"""

import sys
import os
import socket
import argparse

from BaseSpacePy.model.QueryParameters import QueryParameters as qp
from BaseSpacePy.api.BaseMountInterface import BaseMountInterface
from BaseSpacePy.api.BaseSpaceException import ServerResponseException

from .. import __version__, __log_terse_level__
from ..common import ordinal
from ..common.Fastq import Fastq, FastqReadException
from ..common.interface import InternalCommand

VALIDATION_TEXT = """
Fastq files are validated based on the following criteria:
    - The uploader will only support gzipped FASTQ files generated on Illumina instruments
    - The name of the FASTQ files must conform the following convention:
        SampleName_SampleNumber_Lane_Read_FlowCellIndex.fastq.gz
        (i.e. SampleName_S1_L001_R1_001.fastq.gz / SampleName_S1_L001_R2_001.fastq.gz)
    - The read descriptor in the FASTQ files must conform to the following convention:
        @Instrument:RunID:FlowCellID:Lane:Tile:X:Y ReadNum:FilterFlag:0:SampleNumber
        - Read 1 descriptor would look like this:
        @M00900:62:000000000-A2CYG:1:1101:18016:2491 1:N:0:13
        - Read 2 would have a 2 in the ReadNum field, like this:
        @M00900:62:000000000-A2CYG:1:1101:18016:2491 2:N:0:13
Quality considerations
    - The number of base calls for each read must equal the number of quality scores
    - The number of entries for Read 1 must equal the number of entries for Read 2
    - The uploader will determine if files are paired-end based on the matching file names in which the only difference is the ReadNum
    - For paired-end reads, the descriptor must match for every entry for both reads 1 and 2
    - Each read has passed filter
"""


class ShowValidationRules(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        print VALIDATION_TEXT
        sys.exit(0)


class SampleUploadException(Exception):
    def __init__(self, value):
        self.parameter = 'Problem uploading sample: ' + value

    def __str__(self):
        return repr(self.parameter)

class SampleUpload(InternalCommand):
    "upload a FASTQ-based sample into a BaseSpace project."

    REPORT_EVERY = 5000000

    __category__ = "Creating and listing"

    def __init__(self, app, app_args, cmd_name=None):
        super(SampleUpload, self).__init__( app, app_args, self.__class__.__name__ )
        self.allow_invalid_readnames = False
        return

    def get_parser(self, prog_name):
        parser = super(SampleUpload, self).get_parser(prog_name)
        parser.add_argument('fastq', nargs='+', help="files to upload")
        required = parser.add_argument_group('required arguments')
        required.add_argument('-p', '--project', type=str, dest="project", required=True,
                                    help="a BaseSpace project name or ID")
        required.add_argument('-i', '--sample-id', type=str, dest="sample_id",
                                    help="The Id and name of the Sample")
        parser.add_argument('-e', '--experiment', type=str, dest="experiment", required=False,
                                  help="name of the run from which the sample was taken "
                                       "(defaults to information about system and user)")
        parser.add_argument('--show-validation-rules', action=ShowValidationRules, nargs=0,
                                  help="show rules used to validate fastq files and then exit")
        parser.add_argument('--allow-invalid-readnames', action="store_true", default=False)
        return parser

    def take_action(self, parsed_args):
        if parsed_args.show_validation_rules:
            self.print_validation_rules()
            return
        self.allow_invalid_readnames = parsed_args.allow_invalid_readnames
        user           = self.api.getUserById('current')
        origin         = "Uploaded by %s, using %s v%s on %s" % ( user,
                                                                  self.full_name,
                                                                  __version__,
                                                                  socket.getfqdn() )
        # see whether the user has specified a BaseMount path as a project
        if os.path.exists(parsed_args.project):
            bmi = BaseMountInterface(parsed_args.project)
            if bmi.type != "project":
                raise SampleUploadException("BaseMount path not a project!")
            proj = self.api.getProjectById(bmi.id)
        else:
            proj = None
            try:
                proj = self.api.getUserProjectByName(parsed_args.project)
            except ServerResponseException:
                pass
            try:
                proj = self.api.getProjectById(parsed_args.project)
            except ServerResponseException:
                pass
            if proj is None:
                raise SampleUploadException("Could not find project: %s" % parsed_args.project)

        fastqs = []
        for f in parsed_args.fastq:
            F = Fastq(f, self.allow_invalid_readnames)
            fastqs.append(F)

        sample_id = ""
        if parsed_args.sample_id:
            sample_id = parsed_args.sample_id
        else:
            all_sample_names = set((fastq.file_sample_name for fastq in fastqs))
            if not len(all_sample_names) == 1:
                raise SampleUploadException("Mismatching sample names in files: %s" % list(all_sample_names))
            sample_id = list(all_sample_names)[0]

        sample_name = sample_id
        if parsed_args.experiment == None:
            parsed_args.experiment = origin

        self.log.info("Gathering metadata and validating fastq files...")
        if self.is_paired_end(fastqs):
            self.log.debug("validating fastq files in pairs...")
            count, read_length = self.validate_all_fastq_pairs(fastqs)
        else:
            self.log.debug("validating fastq files individually...")
            count, read_length = self.validate_all_fastq_singles(fastqs)

        if self.app.options.dry_run:
            l = len(fastqs)
            self.log.info("Would have uploaded %d file%s into sample '%s'..."
                          % (l, "s" if l > 1 else "", sample_name))
            for f in fastqs:
                self.log.info("... %s" % f.path)
                self.log.info("\t          read number: %s" % f.read_num)
                self.log.info("\t          read length: %d" % f.read_length)
                self.log.info("\t      number of reads: %d" % f.count)
        else:
            self.log.info("Uploading ...")
            # need to find out the number of samples to get the sample number for upload
            samples = proj.getSamples(self.api,qp({'Limit':1024}))
            num_samples = len(samples)
            this_sample = num_samples + 1
            read_lengths = [ self.read_length(fastqs,rn) for rn in ["1","2"]
                                                         if self.read_length(fastqs,rn) != 0 ]

            s = proj.createSample( self.api,
                                   sample_name,
                                   parsed_args.experiment,
                                   this_sample,
                                   sample_id,
                                   read_lengths,
                                   # all reads must be PF, so these two numbers are the same
                                   count,
                                   count,
                                   appSessionId="" )
            ssn = self.api.getAppSessionById(s.AppSession.Id)

            for f in fastqs:
                if parsed_args.sample_id:
                    file_name = f.get_filename_with_samplename(parsed_args.sample_id)
                else:
                    file_name = f.filename
                file = s.uploadFile( self.api,
                                     f.path,
                                     file_name,
                                     "",
                                     'application/octet-stream' )
                self.log.info("\t%s ..... %s " % (f.filename, file.UploadStatus))
            ssn.setStatus(self.api, 'Complete', "finished uploading sample %s" % sample_name)
        if self.app.options.terse and not self.app.options.dry_run:
            self.log.log(__log_terse_level__, "%s" % s.Id)
        if not self.app.options.dry_run:
            self.log.info("Uploaded sample with ID: %s" % s.Id)
            self.log.info(origin)

    @staticmethod
    def has_read_num(fastqs, read_num):
        return any((fastq.read_num == read_num for fastq in fastqs))

    def is_paired_end(self, fastqs):
        return self.has_read_num(fastqs,"2")

    def read_length(self, fastqs, read_num):
        if not(self.has_read_num(fastqs,read_num)):
            return 0
        return max( [f.read_length for f in fastqs
                                   if f.read_num == read_num] )

    @staticmethod
    def find_fastq_pair(fastq, fastqs):
        assert fastq in fastqs
        sample_name, sample_number, lane, read, flowcell_index = fastq.get_file_pieces(fastq.filename)
        if fastq.read_num == "1":
            read = "R2"
        elif fastq.read_num == "2":
            read = "R1"
        else:
            raise SampleUploadException("Unknown read type: %s" % fastq.read_num)
        new_filebase = "_".join([sample_name, sample_number, lane, read, flowcell_index])
        new_filepath = os.path.join(os.path.dirname(fastq.path), "%s" % new_filebase)
        matching = [fastq for fastq in fastqs if fastq.path == new_filepath]
        if len(matching) > 1:
            raise SampleUploadException("Found more than one matching fastq file for: %s" % fastq.path)
        if len(matching) == 0:
            raise SampleUploadException("Found no matching fastq file for: %s" % fastq.path)
        return matching[0]

    def validate_all_fastq_pairs(self, fastqs):
        seen = set()
        total_count = 0
        all_read_length = None
        for fastq in fastqs:
            if fastq in seen:
                continue
            else:
                pair = self.find_fastq_pair(fastq, fastqs)
                count, read_length = self.validate_fastq_file_pair(fastq, pair)
                if all_read_length is None:
                    all_read_length = read_length
                else:
                    if read_length != all_read_length:
                        raise FastqReadException("read lengths do not match between files")
                total_count += count
                seen.add(fastq)
                seen.add(pair)
        return total_count, all_read_length

    def validate_fastq_file_pair(self, fastq1, fastq2):
        first_fh = fastq1.get_reads()
        second_fh = fastq2.get_reads()
        read_num = 0
        while 1:
            if read_num and read_num % self.REPORT_EVERY == 0:
                self.log.info("validated %s reads" % read_num)
            try:
                first = first_fh.next()
                second = second_fh.next()
                if not self.allow_invalid_readnames and first != second:
                    raise FastqReadException("non-matching reads! (%s, %s)" % (first, second))
            except StopIteration:
                break
            read_num += 1
        if fastq1.count != fastq2.count:
            raise FastqReadException("Number of reads do not match: %s, %s" % (fastq1.path, fastq2.path))
        if fastq1.read_length != fastq2.read_length:
            raise FastqReadException("Length of reads do not match: %s, %s" % (fastq1.path, fastq2.path))
        return fastq1.count, fastq1.read_length

    def validate_all_fastq_singles(self, fastqs):
        seen = set()
        total_count = 0
        all_read_length = None
        for fastq in fastqs:
            if fastq in seen:
                continue
            else:
                count, read_length = self.validate_fastq_file_single(fastq)
                if all_read_length is None:
                    all_read_length = read_length
                else:
                    if read_length != all_read_length:
                        raise FastqReadException("read lengths do not match between files")
                total_count += count
        return total_count, all_read_length

    def validate_fastq_file_single(self, fastq):
        fastq_fh = fastq.get_reads()
        # as we pass through each read we validate it
        read_num = 0
        for read in fastq_fh:
            if read_num and read_num % self.REPORT_EVERY == 0:
                self.log.info("validated %s reads" % read_num)
            pass
            read_num += 1
        return fastq.count, fastq.read_length
