#
# Copyright (c) 2016 Illumina, Inc.
#
# This software is provided under the terms and conditions of the
# Illumina Open Source Software License 1.
#
# You should have received a copy of the Illumina Open Source
# Software License 1 along with this program. If not, see
# <https://github.com/sequencing/licenses/>
#

"""
Read the event history of a BaseSpace user

"""
import csv
import json

from ..common.interface import InternalCommand
import requests

class HistoryException(Exception):
    pass


# from here:
# http://stackoverflow.com/questions/21663800/python-make-a-list-generator-json-serializable
class StreamArray(list):
    def __init__(self, gen):
        super(StreamArray, self).__init__()
        self._gen = gen

    def __iter__(self):
        return self._gen

    # according to the comment below
    def __len__(self):
        return 1

class History(InternalCommand):
    "Get the event history for a user"

    __category__ = "Creating and listing"

    FLAT_HEADERS = [
        "Id",
        "DateCreated",
        "ResourceType",
        "ResourceId",
        "ActingUserId",
        "LoggedInUserName",
        "LoggedInUserId",
        "ActingUserName",
        "IpAddress",
        "EventType",
    ]

    TRANSITION_HEADERS = [
        "FieldChanges"
    ]

    DICT_HEADERS = [
        "Metadata"
    ]


    def __init__(self, app, app_args, cmd_name=None):
        super(History, self).__init__( app, app_args, self.__class__.__name__ )
        self._accesstoken = None
        self._apiuri = None
        self._userid = None
        return

    def get_parser(self, prog_name):
        parser = super(History, self).get_parser(prog_name)
        parser.add_argument('--json', action="store_true", default=False, help="output events as json")
        parser.add_argument('--domain', action="store_true", default=False, help="select domain events. Only available if you have the AUDIT DOMAIN scope")
        return parser

    def get_user_details(self, domain):
        user_endpoint = self._apiuri + "/users/current/"
        headers = {
            "x-access-token" : self._accesstoken
        }
        response = requests.get(user_endpoint, headers=headers)
        response_json = response.json()["Response"]
        self._userid = response_json["Id"]
        if domain:
            if "HrefDomain" in response_json:
                domain_endpoint = response_json["HrefDomain"]
                domain_repsonse = requests.get(domain_endpoint, headers=headers)
                domain_json = response.json()["Response"]
                self._historyapi = domain_json["HrefHistory"]
            else:
                raise HistoryException("Could not derive domain history API endpoint - does this BaseSpace instance support entity history?")
        elif "HrefHistory" in response_json:
            self._historyapi = response_json["HrefHistory"]
        else:
            raise HistoryException("Could not derive history API endpoint - does this BaseSpace instance support entity history?")

    # including handling the pagination
    def get_all_logs(self):
        queryParams = {
            "Limit" : 1024,
            "SortBy" : "DateCreated",
        }
        headers = {
            "Authorization" : "Bearer %s" % self._accesstoken
        }

        total_number = None
        number_received = 0

        after = None
        while total_number is None or number_received < total_number:
            if after:
                queryParams["after"] = after
            # this might raise an exception - this would just propagate and be the error message
            response = requests.get(self._historyapi, params=queryParams, headers=headers)
            response_json = response.json()
            if "Items" not in response_json:
                raise HistoryException("Could not find history items. Do you have the AUDIT USER scope?")
            for entry in response_json["Items"]:
                yield entry
            paging = response_json["Paging"]
            total_number = paging["TotalCount"]
            after = paging["After"]
            number_received += paging["Limit"]


    # entries can be a generator function!
    def entries_to_dicts(self, entries):
        for entry in entries:
            flat_dict = dict((header, entry[header] if header in entry else "") for header in self.FLAT_HEADERS)
            transition_dict = {}
            for transition_header in self.TRANSITION_HEADERS:
                transitions_as_strings = []
                for varname in entry[transition_header]:
                    transition = entry[transition_header][varname]
                    old_value = transition["OldValue"] if "OldValue" in transition else ""
                    new_value = transition["NewValue"] if "NewValue" in transition else ""
                    transitions_as_strings.append("%s : %s -> %s" % (varname, old_value, new_value))
                transition_dict[transition_header] = ";".join(transitions_as_strings)
            dict_dict = {}
            for dict_header in self.DICT_HEADERS:
                dict_as_string = ";".join(("%s:%s" % (key, entry[dict_header][key]) for key in entry[dict_header]))
                dict_dict[dict_header] = dict_as_string
            all_dict = {}
            all_dict.update(flat_dict)
            all_dict.update(transition_dict)
            all_dict.update(dict_dict)
            yield all_dict

    def logs_to_csv(self, log_entries):
        headers = self.FLAT_HEADERS + self.TRANSITION_HEADERS + self.DICT_HEADERS
        writer = csv.DictWriter(self.app.stdout, fieldnames=headers)
        # I can't use writer.writeheaders because that's new to python2.7
        writer.writer.writerow(headers)
        for entry in self.entries_to_dicts(log_entries):
            writer.writerow(entry)

    def take_action(self, parsed_args):
        self._accesstoken = self.api.apiClient.apiKey
        self._apiuri = self.api.apiClient.apiServerAndVersion
        # this includes getting the history API from the users/current endpoint
        self.get_user_details(parsed_args.domain)
        try:
            if parsed_args.json:
                json.dump(StreamArray(self.get_all_logs()), self.app.stdout)
            else:
                self.logs_to_csv(self.get_all_logs())
        except Exception as e:
            raise HistoryException("Cannot get history: %s" % str(e))
